
1. S – Single Responsibility (Принцип единственной ответственности)
   Каждый класс, созданный на семинаре №4 отвечает за одну операцию (в расширенном смысле).
    
    Я бы единственно, что изменил - метод:
    public void addGroup(Student student){
        studentList.add(student);
   }
    перенес из класса StudentGroup в класс StudentGroupService. Именно в классе StudentGroupService мы совершаем 
    ДЕЙСТВИЯ c StudentGroup (создаем группу, создаем студента в группе, сортируем группу, получаем список студентов) и,
    соответственно, добавление студента я бы перенес в StudentGroupService. Тогда бы полностью соблюдался Принцип
    единственной ответственности - действия с группой в один класс.
    
2. O — Open-Closed (Принцип открытости-закрытости). Классы должны быть открыты для расширения,но закрыты для модификации.
    В нашем случае - это класс User и его расширение  - класс Student (но не модификация).

3. L — Liskov Substitution (Принцип подстановки Барбары Лисков)
    В нашем случае мы использовали этот принцип в интерфейсе:
    public interface UserView<T extends User> {
    void sendOnconsole(List<T> list);
    }
    где класс Т всегда будет расширением класса User и будет корректно все работать и с User и с классом Т;

4. I — Interface Segregation (Принцип разделения интерфейсов)
    В чистом виде на семинаре №4 этого нет.

5. D — Dependency Inversion (Принцип инверсии зависимостей)
    В нашем случае - Это класс StudentGroup использует инструмент StudentGroupService через абстракцию UserView
    
